# 12장 다형성

## 스터디 날짜
2022/02/10

## 1. 다형성
### 상속의 목적은 코드 재사용이 아니다. 상속은 타입 계층을 구조화하기 위해 사용해야 한다.
![img0](https://user-images.githubusercontent.com/71916223/153323090-70e93ae3-0320-4773-b104-ffbeb4466c34.PNG)                                         
<br>
강제 다형성 : 동일한 연산자를 다양한 타입에 사용할 수 있는 방식<br>
(예 - 자바 이항 연산자 + 는 피연산자가 모두 정수일 때는 정수에 대한 연산자로, 문자열일때는 연결 연산자로 이용된다)<br>
매개변수 다형성 : 제네릭 프로그래밍과 연관이 되는데 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타이으로 지정<br>
(예 - ArrayList<T> list = new ArrayList<>();)<br>
포함 다형성 : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력(= 서브타입(Subtype) 다형성)
(예 - 상속 사용시 부모 클래스의 메서드를 자식 클래스에서 오버라이딩 하고 부모 클래스 참조)<br>
 
## 2. 상속의 양면성
객체 : 행동 + 데이터 -> 데이터와 행동 두가지 관점으로 고려해보자.<br>
상속 : 프로그램은 구성하는 개념들을 기반으로 다형성을 기능하게 하는 타입 계층을 구축하기 위한 것<br>
### 데이터 관점의 상속
자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함.
### 행동 관점의 상속
공통적으로 부모 클래스의 모든 퍼블릭 메서드는 자식 클래스의 퍼블릭 인터페이스에 포함된다.<br>
(이유 : 런타임에 시스템이 자식 클래스에 정의되자 않은 메서드는 부모 클래스 안에서 탐색)<br>
![img1](https://user-images.githubusercontent.com/71916223/153323098-dce93ffc-dbec-462d-9ff1-0a4332fd41c9.PNG)
<br>
객체와 달리 메서드의 경우 동일한 클래스의 인스턴스끼리 공유가 가능하기 떄문에 클래스는 한번만 메모리에 로드하고 각 인스턴스별로 클래스를 가리키는 포인터를 갖게 하는 것이 경제적이다.
  
## 3. 업캐스팅과 동적 바인딩
업캐스팅 : 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다.<br>
동적 바인딩 : 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다.(실행 메서드는 컴파일 시점이 아니라 실행 시점에 결정)<br>
![img2](https://user-images.githubusercontent.com/71916223/153323135-51a6c19b-5e1c-453b-88b0-bc9dd5951f3e.PNG)

```java
Lecture lecture = new GradeLecture(...); 
// 업캐스팅 : 컴파일러는 명시적인 타입 변환 없이 자식 클래스가 부모 클래스를 대체할 수 있게 허용한다.
// 어떤 자식 클래스와도 협력이 가능한 무한한 확장 가능성을 가진다 - 유연하고 용이한 설계
```

동적바인딩(dynamic binding) = 지연 바인딩(late binding) : 실행될 메서드를 런타임에 결정하는 방식<br>
  
## 4. 동적 메서드 탐색과 다형성
- 메시지를 수신한 객체는 자신을 생성한 클래스에 적합한 메서드가 있는지 탐색
- 메서드가 없으면 부모 클래스에서 탐색
- 최상위 클래스(Objet) 까지 탐색하고 없으면 예외 발생
![img3](https://user-images.githubusercontent.com/71916223/153323141-d70c5e98-6cd6-4519-a7d5-aac2c9a71e9e.PNG)
<br>

이 모든 과정은 자동적인 메시지 **위임**으로 이루어진다.<br>
**상속계층**을 정의하는 것은 **메서드 탐색 경로**를 정의하는 것과 동일하다.<br>

![img4](https://user-images.githubusercontent.com/71916223/153323152-455567a2-d8e9-4e25-983d-75ba594bf357.PNG)
<br>
self 전송은 self 참조부터 탐색을 다시 시작하게 만든다.<br>
self 전송이 깊은 상속 계층과 중간중간 함정처럼 숨겨져 있는 메서드 오버라이딩과 만나면 극단적으로 이해하기 어려운 코드가 만들어진다.

## 5. super
super 참조 : 지금 이 클래스의 부모 클래스에서부터 메서드 탐색을 시작하세요. 즉 부모 클래스부터 Object 까지 탐색이 이루어진다.<br>
super 같은 경우 구체 클래스 내에서 코드를 통해 실제 탐색 시점 클래스를 유추할 수 있기 떄문에 컴파일 시점에 super 전송이 결정된다.<br>
*믹스인과 같이 언어의 특성에 따라 super 가 런타임에 결정될 수도 있다.*
 
## 6. 상속 대 위임
![img5](https://user-images.githubusercontent.com/71916223/153323153-f2eb4e93-558e-44f4-93d5-1583e387dd61.PNG)
<br>
메서드 탐색 중에는 자식 클래스의 인스턴스와 부모 클래스의 인스턴가는 동일한 self 참조를 공유한다.

### 포워딩과 위임
  
## 7. 프로토 타입 기반의 객체지향 언어
프로토타입(prototype) : 클래스가 존재하지 않고 오직 객체만 존재하는 프로토타입 기반의 객체지향 언어에서 상속을 구현하는 유일한 벙법은 객체 사이의 위임을 이용하는 것이다.
  

### 업캐스팅
### 동적 메서드 탐색
### 동적 바인딩
### self 참조
### super 참조
  

