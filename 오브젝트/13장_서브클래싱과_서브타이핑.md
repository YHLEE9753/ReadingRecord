# 13장 서브클래싱과 서브타이핑

## 스터디 날짜
2022/02/14

### 상속의 용도
1. 코드 재사용
2. 타입 개층 구현(부모 클래스는 일반적인 개념 구현, 자식 클래스는 특수한 개념 구현)<br>
부모 클래스는 자식 클래스의 **일반화(generalization)**, 자식 클래스는 부모 클래스의 **특수화(specialization)**

상속의 진짜 목표는 타입계층을 구현하여 다형적으로 동작하는 객체들의 관계에 기반하여 확장 가능하고 유연한 설계를 얻는 것이다.


## 1. 타입
### 개념 관점의 타입
**심볼(symbol)** : 타입에 이름을 붙인 것<br>
**내연(intension)** : **타입의 정의**로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동<br>
**외연(extension)** : 타입에 속하는 **객체들의 집합**<br>

### 프로그래밍 언어 관점의 타입
프로그래밍 언어에서 타입은 2가지 목적을 위해 사용된다.
- 타입에 수행할 수 있는 유효한 오퍼레이션의 집합을 정의
모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 프로그래머의 실수를 막아준다.(ex +연산자가 사용 가능한 타입은 정해져 있다.) 
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공
(ex)자바에서 +연산자는 int 는 합을 String 은 concat 의 의미를 가진다.)

### 객체지향 패러다임의 관점의 타입
지금 까지의 타입
- 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류
- 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합

<br>
객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 **퍼블릭 인터페이스**를 정의하는 것과 동일하다.<br>
객체지향에서는 객체가 수신할 수 있는 메시지를 기준으로 타입을 분류한다<br>
**객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류한다.**

## 2. 타입 계층
슈퍼타입(supertype) : 더 일반적인 타입<br>
서브타입(subtype) : 더 특수한 타입<br>
ex)프로그래밍언어는 객체지향 언어의 슈퍼타입, 클래스기반 언어는 객체지향 언어의 서브 타입<br>
<br>
외연의 관점(집합)<br>
슈퍼셋(superset) : 일반적인 타입의 인스턴스 지합은 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋이다.
서브셋(subset) : 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 서브셋이다.
<br>
### 슈퍼 타입의 특징
- 집합이 다른 집합의 모든 멤버를 포함한다.
- 타입 정의가 다른 타입보다 좀 더 일반적이다.

### 서브 타입의 특징
- 잡합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
- 타입 저으이가 다른 타입보다 좀 더 구체적이다.

### 서브 타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다 이사실이 핵심이다.

## 3. 서브클래싱과 서브타이핑
### 언제 상속을 사용해야 하는가?
- 상속 관계가 is-a 관계를 모델링하는가? ex) [자식 클래스]는 [부모 클래스]이다.
- 클라이언트 입장에서 부모클래스의 타입으로 자식 클래스를 사용해도 무방한가? 클라이언트는 부모 클래스와 자식 클래스의 차이를 몰라야한다. : **행동 호환성**

### 두 클래스에 대해 기대하는 행동이 다르다면 비록 그것이 어휘적으로 is-a 관계로 표현할 수 있더라도 상속을 사용해서는 안된다!

### is-a 관계
타입 계층의 의미는 행동이라는 문맥에 따라 달라진다.<br>
펭귄은 새이다 : is a 관계를 만족하는 것 같다.<br><br>
하지만 **클라이언트**가 새에게 요구하는 행동이 하늘을 날다 이라면 펭귄은 하늘을 날지 못하기 때문에 두 관계는 **행동 호환성**이 존재하지 않는다.따라서 is-a 관계가 아니다<br>
행동의 호환 여부를 판단하는 기준은 **클라이언트의 관점** 이다.<br>
<br>
이러한 경우 bird 에서 instanceof 를 통해 펭귕이 아닐때만 fly 하게 하거나, 예외를 던지거나 if 문처리를 해야 되는데, 새로운 타입 추가시 코드 수정이 필요하므로 개방-폐쇄 원칙을 위반한다.

### 클라이언트 기대에 따라 상속 계층 분리<br>
![1](https://user-images.githubusercontent.com/71916223/153787999-92fae6e4-0d96-4cd6-9d21-bbac0436362f.PNG)<br>
<br>
이런 경우 펭귄에게 fly 메시지를 전송할 일이 없다.
### 클라이언트 기대에 따른 인터페이스 분리<br>
![2](https://user-images.githubusercontent.com/71916223/153788004-adef878b-70fc-427a-b6c9-30c866446ee9.PNG)<br>
<br>
이런 경우 펭귄이 bird 를 상속받아도 문제가 안되지만 fly 오퍼레이션이 추가되기때문에 이 방법을 사용할 수 없다.
### 합성을 이용한 코드 재사용<br>
![3](https://user-images.githubusercontent.com/71916223/153788006-0bb2d222-0036-46be-9838-240c17537d53.PNG)<br>
<br>
합성을 쓰면 위 문제가 해결된다. 불안정한 상속 계층을 껴안고 가는 것보다는 bird 를 재사용할 수 있게 수정하는 것이 더 좋다.(합성 다시 복습하고 이부분도 다시 확인하자)

### 인터페이스 분리 원칙(Interface Segregation Principle, ISP)
인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙<br><br>
클라이언트에 따라 인터페이스를 분리하면 각 클라이언트의 요구가 바뀌더라도 영향의 파급 효과를 효과적으로 제어할 수 있다.<br><br>
예를 들어 위 3번쨰 그림에서 Flyer 의 인터페이스가 변경되어야 한다면 이경우 Bird 가 영향을 받게 되고 변경의 영향은 Bird 에서 끝난다. client 는 Flyer 이나 Bird 에 대해 전혀 알지 못하기 때문에 영향을 받지 않는다.
<br><br>
클라이언트는 자신이 실제로 호출하는 메서드에만 의존해야 한다. 비대한 클래스의 인터페이스를 여러개의 클라이언트에 특화된 인터페이스로 분리함으로써 성취할 수 있다.<br>

### 서브클래싱과 서브타이핑
서브클래싱(subclassing) : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우(구현 상속(implementation inheritance) 또는 클래스 상속(class inheritance)라고도 불린다.)<br><br>
서브타이핑(subtyping) : 타입 계층을 구성하기 위해 상속을 사용하는 경우. 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.(인터페이스 상속(interface inheritance)라고도 불린다..)
<br><br>
인터페이스 상속관계를 갖는 경우 프로그램에는 슈퍼타입으로 정의하지만 런타임에 서브타입의 객체로 대체할 수 있다.<br>
서브 타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다. = 행동 호환성(behavioral substitution) 을 만족<br><br>
대체 가능성(substitutability) : 자식 클래스가 부모 클래스가 사용되는 모든 문맥에서 자식 클래스와 동일하게 행동할 수 있어야한다. 부모 클래스를 새로운 자식 클래스로 대체하더라도 시스템이 문제없이 동작할 것을 보장해야 한다.<br>
<br>

## 4. 리스코프 치환 원칙(Liskov Substitution Principle, LSP)
서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.<br>
클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.<br>
자식 클래스가 부모 클래스와 행동 호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된 상속 관계만을 서브타이핑이라고 불러야 한다.<br>
<br>
예) 직사각형과 정사각형 : is a 관계같지만 실제로는 크라이언트가 기대하는 가정이다르다<br>
정사각형은 두변이 동일하고 직사각형은 다르다 따라서 가정이 달라 resize 함수 생성시 오류 발생 : 이것은 is a 관계인 서브타이핑이 아니라 구저 구현을 재사용한 서브클래스이다.<br>
<br>
<br>
리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다.<br>
결론적으로 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계이다. 서브클래싱을 구현하기 위해 사용했다면 is-a 관계라고 부를 수 없다.<br>
<br>
OCP 만족시 LSP를 만족한다.<br>
LSP 는 OCP 를 만족하는 설계를 위한 전제조건이다. - LSP 만족시 자식클래스를 추가하더라도 코드 수정이 필요 없기 때문

## 5. 계약에 의한 설계와 서브타이핑
사전조건(precondition) : 메서드를 실행하기 위해 만족시켜야하는 조건<br>
사후조건(postcondition) : 메서드 실행된 후 서버가 클라이언트에게 보장해야 하는 조건<br>
클래스 불변식(class invariant) : 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 조건<br> 

**클라이언트는 슈퍼타입의 조건만 알고 있다. -> 서브타입은 런타임에 할당되므로**
### 서브타입에 더 강력한 사전조건을 정의할 수 없다.
항시 가능으로 알고 있는데 더 강한 사전 조건이 있으면 협력에 싪패
### 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
### 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
최소조건만 달성하면 문제가 안되므로 더 강해도 상관없다. 근데 최소조건을 약하게 해버리면 협력에 실패
### 서브타입에 더 약한 서후조건을 정의할 수 없다.



