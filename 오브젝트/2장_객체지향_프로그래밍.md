# 2장 객체지향 프로그래밍

## 스터디 날짜
2021/12/31


## 1. 객체지향 프로그래밍
객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞추어야 얻을 수 있다.<br>
이를 위해 2가지를 고민하자
1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하자
   - 클래스의 윤곽을 잡기전 어떤 객체들이 어떤 **상태** 와 **행동** 을 가지는지 먼저 결정하자
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.
   - 공동체의 일원으로 바라보는 것이 설계를 유연하고 확장 가능하게 만든다.
   - 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하자.

## 2. 도메인
객체지향 패터다임 설계에 도메인을 이용하자<br>
요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있다.
<br><br>
클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야한다.

## 3. 클래스 구현
훌륭한 클래스 설계의 핵심 : 어떤 부분을 외부에 공개하고 어떤 부분을 감출지 결정<br>
클래스의 내부 외부 구분의 이유
### 1. 경계의 명확성 : 객체의 자율성 보장
a. 객체 : 상태(state) 와 행동(behavior) 을 함꼐 가지는 복합적인 존재.<br>
b. 객체 : 스스로 판단하고 행동하는 자율적인 존재<br>

캡슐화 : 데이터와 기능을 한 덩어리로 묶음

접근제어(access control) : 접근을 통제하여 객체를 자율적인 존재로 부여 by 외부의 간섭을 최소화

퍼블릭 인터페이스(public interface) : 외부에서 접근 가능 부분

구현(implementation) : 외부에서 접근 불가능하고 오직 내부에서만 접근 가능

**인터페이스와 구현의 분리(separation of the interface and implementation)** 원칙은 훌륭한 객체지향 프로그램을 만들기 위한 핵심 원칙이다.

클래스 작성자(class creator) : 새로운 타입을 프로그램에 추가 - 클라이언트에게 필요한 부분만 공개하고 나머지는 숨김, 클라이언트 프로그래머 걱정없이 내부 구현을 마음대로(구현은닉)

클라이언트 프로그래머(client programmer) : 클래스 작성자가 추가한 데이터 타입을 사용


## 4. 협력
객체의 내부 상태는 외부에서 접근하지 못하도록 감추어야 한다. 대신 외부에 공개하는 퍼블릭 인터페이스를 통해 내부 상태에 접근할 수 있도록 허용한다.<br>
요청(request) : 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청
응답(response) : 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답

객체가 다른 객체와 상호작용할 수 있는 유일한 방법 : 메시지를 전송

### 메시지와 메서드를 구분하는 것은 매우 중요하다!!!!
### 인터페이스로 호출 시 내부메서드가 무엇인지는 알 수 없다.(인터페이스와 구현의 분리) 따라서 메서드 호출이 아닌 메시지 전송이 다형성의 의미에서 맞는말이다.

### 그 후 어떤 메서드를 사용해서 처리할 지는 객체의 자율적인 문제이다


## 5. 상속과 다형성
유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다.

코드의 의존성과 실행 시점의 의존성이 다르면 다를 수록 코드를 이해하기 어려워진다. 하지만 더 유연해지고 확장 가능해진다.
### 의존성의 양면성은 트레이드오프 - 유연성과 가독성 사이에서 고민해라!!

상속 : 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있다. <br>
인터페이스 : 객체가 이해할 수 있는 메시지의 목록을 정의<br>
자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주


지연 바인딩(lazy binding) or 동적 바인딩(dynamic binding) : 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다. 즉 메시지와 메서드를 실행 시점에 바인딘한다는 것이다.

객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 바로 지연 바인딩이라는 메커니즘을 사용하기 때문

인터페이스 : 구현에 대한 고려 없이 다형적인 협력에 참여하는 클래스들이 공유 가능항 외부 인터페이스


## 6. 합성
### 상속의 문제점
1. 캡슐화를 위반 - 부모클래스의 구조를 잘 알아야한다.
2. 설계를 유연하지 못하게 만든다. - 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정하므로 실행 시점에 객체의 종류를 변경하는 것이 불가능

합성 : 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법
1. 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하므로 구현을 효과적으로 캡슐화
2. 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.

``` java
public class Movie {
    private DiscountPolicy discountPolicy;
    
    public void changeDiscountPolicy(DiscountPolicy discountPolicy){
        this.discountPolicy = discountPolicy;
    }
}
```
``` java
Movie avatar1 = new Movie("아바타",
    Duration.ofMinutes(120),
    Money.wons(10000),
    new AmountDiscountPolicy(Money.wons(800), ... )));
avatar.changeDiscountPolicy(new PercentDiscountPolicy(0.1, ...));
```
상속의 경우 부모 클래스와 자식 클래스가 강하게 결합되어 인스턴스를 새로 복사해야 되지만 합성의 경우 설계가 굉장히 유연하다.

https://velog.io/@ljinsk3/%EC%83%81%EC%86%8D%EA%B3%BC-%ED%95%A9%EC%84%B1 참고
