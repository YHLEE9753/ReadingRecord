# 5장 책임 할당하기

## 스터디 날짜
2022/01/11



## 1. 책임 주도 설계
객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정된다<br>
**책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다.**<br>
따라서 협력에 적합한 책임이란 메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 의미한다.<br>
**메시지를 결정한 후에 객체를 선택해야 한다(메시지가 객체를 선택)**<br>

## 2. 책임 할당을 위한 GRASP 패턴
GRASP 패턴 : General Responsibility Assignment Software Pattern(일반적인 책임 할당을 위한 소프트웨어 패턴)<br>

1. 정보 전문가에게 책임을 할당하라.
메시지는 메시지를 수신할 객체가 아니라 메시지를 전송할 객체의 의도를 반영해서 결정해야한다.<br>
첫번째 질문 : 메시지를 전송할 객체는 무엇을 원하는가? ex) 예매하라<br>
두번째 질문 : 메시지를 수신할 적합한 객체를 누구인가?<br>

객체가 상태와 행동을 통합한 캡슐화의 단위이다.<br>
객체에게 책임을 할당하는 **첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체**에게 책임을 할당하는 것이다.<br>
GRASP 에서 이를 INFORMATION EXPERT(정보 전문가) 패턴이라고 부른다.<br>

### INFORMATION EXPERT
책임을 수행하는데 필요한 정보를 가지고 있는 객체에게 할당하라.<br>
객체는 자율적인 존재이다. 정보와 행동을 최대한 가까운 곳에 위치시키기 때문에 캡슐화를 유지할 수 있다.<br>
여기서 이야기하는 정보는 데이터와 다르다. 책임을 수핸하는 객체가 정보를 '알고' 있다고 해서 그 정보를 '저장'하고 있을 필요는 없다.<br>
어떤 방식이건 정보전문가가 데이터를 반드시 저장하고 있을 필요는 없다는 사실을 이해하는 것이 중요하다

INFORMATION EXPERT 패턴을 따르는 것만으로도 자율성이 높은 객체들로 구성된 협력 공동체를 구축할 가능성이 높아진다!


### LOW COUPLING(낮은 결합도)
설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.

### HIGH COHESION(높은 응집도)
높은 응집도를 유지할 수 있게 책임을 할당하라

### CREATOR 패턴
어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.<br>
생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것이다. 즉 두 객체는 서로 결합된다.<br>

이미 결합돼 있는 객체에게 생성 책임을 한달하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다.<br>
결과적으로 CREATOR 패턴은 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 낮은 결합도를 유지할 수 있게 한다.


## 3.구현 팁
1. 변경의 이유에 따라 클래스를 분리해야한다.
두가지 변경이 코드에 영향을 미치는 시점이 다를 수 있고 이는 서로 다른 시점에 변경될 확률이 높아 응집도를 낮춘다.<br>

**코드를 통해 변경의 이유를 파악할 수 있는 방법**
- 인스턴스 변수가 초기화되는 시점을 살펴봐라. 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화 한다
**함께  초기화되는 속성을 기준으로 코드를 분리해야 한다.**
- 메서드들이 인스턴스 변수를 사용하는 방식을 살펴봐라. 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다.
**속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.**

2. 다현성을 통해 분리하기

### POLYMORPHISM(다형성) 패턴
객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당

### PROTECTED VARIATIONS(변경 보호) 패턴
변화가 예상되는 불한정한 지점들을 식별하고 그 주위에 **안정된 인터페이스** 를 형성하도록 책임을 할당하라.<br>
클래스를 변경에 따라 분리하고 인터페이스를 이용해 변경을 캡슐화하는 것은 설계의 결합도와 응집도를 향상시키는 매우 강력한 방법이다.<br>

**하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면 클래스를 분해하고 POLYMORPHISM 패턴에 따라 책임을 분산시켜라. 예측 가능한 변경으로 인해 여러 클래스들이 불안정해진다면 PROTECTED VARIATIONS 패턴에 따라 안정적인 인터페이스 뒤로 변경을 캡슐화해라**

## 4. 리팩터링
### 리팩터링(Refactoring) 이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경

### 메서드 응집도
메서드 응집도가 높은 경우 발생하는 문제(몬스터 메서드 Monster method)
1. 전체적인 코드 이해에 시간이 오래 걸린다
2. 하나의 메서드에서 너무 많은 작업을 처리하기 때문에 수정해야 할 부분을 찾기 어렵다
3. 메서드 내부 일부 로직만 변경하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다
4. 로직의 일부만 재사용하는 것이 불가능하다
5. 코드 재사용을 코드를 복붙해야 하므로 코드 중복을 초래하기 어렵다

클래스가 작고, 목적이 명확한 메서드들로 구성돼 있다면 변경을 처리하기 위해 어떤 메서드를 수정해야하는지 쉽게 판단가능. 재사용하기 쉽다.<br>
메서드를 응집도 있는 수준으로 분해하자

### 객체를 자율적으로 만들자
자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것이 자율적인 객체를 만드는 지름길이다.




