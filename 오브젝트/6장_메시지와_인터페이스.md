# 6장 메시지와 인터페이스

## 스터디 날짜
2022/01/17

## 1. 협력과 메시지
### 클라이언트-서버 모델(Client - Server model) 
**두 객체 사이의 협력관계를 설명하기 위한 메타포(단방향 상호작용)**<br>
메시지를 전송하는 객체 : 클라이언트 <br>
메시지를 수신하는 객체 : 서버

### 메시지와 메시지 전송
메시지(message) : 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단<br>
메시지 전송(message sending) = 메시지 패싱(message passing)<br>
메시지 전송자(message sender) = 클라이언트<br>
메시지 수신자(message receiver) = 서버<br>

**메시지 전송 : 메시지 수신자 + 오퍼레이션명 + 인자**<br>
오퍼레이션명(operation name)<br>
인자(argument)
```java
condition.isSatisfiendBy(screening);
// 수신자.오퍼레이션명(인자)
```
메서드 : 메시지를 수신핼을때 실제로 실햄되는 함수또는 프로시저<br>
(동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다. - 다형성에 의한 컴파일 시점과 실행 시점의 차이)<br>

따라서 어떤 메서드가 실행될지 알 수 없지만 어떤 메시지를 전송해야 하는지만 알면 된다. - 유연하고 확장 가능한 코드

### 퍼블릭 인터페이스와 오퍼레이션
퍼블릭 인터페이스(public interface) : 외부에 공개하는 메시지의 집합<br>
오퍼레이션(operation) : 퍼블릭 인터페이스에 포함된 메시지 = 수행 가능한 어떤 행동에 대한 추상화<br>

**오퍼레이션은 구현이 아닌 추상화**<br>
**메서드는 오페레이션을 구현한 것**<br>
client 가 1. 메시지 전송시 2.오퍼레이션 호출되고, 3.서버에서 메서드가 실행된다!(180p 6.5 참고)<br>

시그니처(signature) : 오퍼레이션(또는 메서드)의 이름과 파리미터 목록을 합친것.

## 2. 인터페이스와 설계 품질
좋은 인터페이스는 **최소한의 인터페이스**와 **추상적인 인터페이스** 라는 조건을 만족해야한다!!

### 디미터 법칙
**객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것**<br>
클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍 해야 한다
```text
- this 객체
- 메서드의 매개변수
- this 의 속성
- this 의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체
```
부끄럼타는 코드(shy code) : 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드<br>

디미터 법칙이 가치 있는 이유는 클래스를 캡슐화하기 위해 따라야하는 구체적인 지침을 제공하기 때문이다. 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다!<br>

기차 충돌(train wreck) : 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적이 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다.
```java
// 기차 충돌
screening.getMovie().getDiscountConditions();

// 개선된 코드
// 내부구조를 알 필요 없이 자신이 원하는 것이 무엇인지 명시하고 단순히 수행하도록 요청        
screening.calculateFee(audienceCount);
```
<br>


### 묻지 말고 시켜라
**객체의 상태에 관해 묻지 말고 원하는 것을 시켜라!**<br>
객체지향의 기본 : 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합<br>

**묻지 말고 시켜라**를 통해 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.<br>

자연스럽게 정보전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻게 된다.

**상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라!!**
<br>
<br>
<br>

### 의도를 드러내는 인터페이스
1.메서드 이름을 지을 때 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름짓자. 메서드의 이름은 내부의 구현 방법을 드러낸다.
```java
public class PeriodCondition{
    public boolean isSatisfiedByPeriod(Screening screening){...}
}

public class SequenceCondition{
   public boolean isSatisfiedByCondition(Screening screening){...}
}
```
```text
위코드가 좋지 않은 이유
1. 메서드에 대해 제대로 커뮤니케이션 하지 못한다. 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행한다는 사실을 알아채리기 어렵다

2. 캡슐화를 위반 - 협력하는 객체의 종류를 알도록 강요한다.
```

2.메서드 이름을 지을 때 '어떻게' 가 아니라 '무엇'을 하는지를 드러내는 것이다. - 객체가 수행하는 책임에 대해 고민하게 만들자
```text
다형성을 통해 무엇을 하는지를 드러내자(동일한 목적을 가진다는것을 이름으로 명확히 표현

인터페이스를 정의하고 인터페이스에 isSatisfiedBy 오퍼레이션 정의
```

```java
import Object.Chapter2.DiscountCondition;

// 다형성을 이용한 코드 개선
public class PeriodCondition implements DiscountCondition {
   public boolean isSatisfiedBy(Screening screening) {...}
}

public class SequenceCondition implements DiscountCondition{
   public boolean isSatisfiedBy(Screening screening) {...}
```
```java
public interface DiscountCondition{
    boolean isSatisfiedBy(Screening screening);
}
```

**의도를 드러내는 선택자(Intention Revealing Selector)** : 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴<br>

**의도를 드러내는 인터페이스(Intention Revealing Interface)** : 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현




### 명령-쿼리 분리(Command-Query Separation)
루틴(routine) : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈<br>
프로시저(procedure) : 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.<br>
함수(function) : 함수는 값을 반환할 수 있지만 부수효과를 방생시킬 수 없다.<br>

명령(command) : 객체의 상태를 변경하지만 반환값을 가질 수 없다.<br>
쿼리(Query) : 객체의 정보를 반환하지만 상태를 변경할 수 없다<br>

**명령과 쿼리의 두가지 역할을 동시에 수행하는 경우 버그가 발생할 수 있고 추적이 어려워질수 있다**<br>
**코드 작성시 명령과 쿼리를 명확하게 분리하는 습관을 가지자**<br>
**인터페이스가 더 복잡해보일수 있지만 분리로 얻는 이점이 훨씬더 많다!!**<br>
*SRP 원칙가 연결해서 생각해보자*



## 3. 원칙의 함정
설계는 트레이드오프의 산물이.<br>
원칙이 현재 상황에 부적합하다고 판단 시 과감하게 원칙을 무시하라.<br>
언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것이 중요하다.<br>

#### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다
객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것을 디미터 법측을 준수한 것이다 (ex) IntStream)

#### 결합도와 응집도의 충돌
모든 상황에서 맹복적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다.<br>
객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다.<br>
**클래스는 하나의 변경 원인만을 가져야 한다!!!!**<br>

<추가적 정보><br>
객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만 자료 구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.


## 4 .정리
의도를 드러내는 인터페이스 설계 시 메시지를 먼저 선택하고 그 후 메시지를 처리할 객체를 선택하자

- 디미터 법칙 : 객체간의 구조적인 결합도를 낮추자
- 묻지 말고 시켜라 : 상태를 묻지말고 메시지를 통해 시킴으로서 책임할당하라
- 의도를 드러내는 인터페이스 : 메시지 이름 지칭시 의도를 드러내라
- 명령-쿼리 분리 원칙 : 명령 쿼리 분리는 예측 가능한 협력을 만들기 위해 굉장히 중요하다 

## 5. 계약에 의한 설계(Design By Contract)
협력을 위해 클라이언트와 서버가 준수해야하는 제약을 코드 상에 명시적으로 표현하고 강제할 수 있는 방법
