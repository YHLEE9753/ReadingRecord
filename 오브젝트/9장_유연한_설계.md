# 9장 의존성 관리하기

## 스터디 날짜
2022/01/27

## 1. 개방-폐쇄 원칙(Open-Closed Principle, OCP)
**소프트웨어 개체(클래스,모듈,함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.**<br>
- 확장에 대해 열려 있다. 애플리케이션의 요구사항이 변경될 때 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.
- 수정에 대해 닫혀 있다. 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라<br>
의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란 컴파일 의존성을 으ㅠ지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조이다.<br>
변하지 않는 부분을 고정하고 변하는 부분을 생략하는 추상화 메커니즘<br>

결합도가 높아질수록 OCP 를 지키기 어려워진다.<br>
-><br>
**생성과 사용을 분리(separating use from creation)**하자

### 1. 객체를 생성할 책임을 클라이언트에게 옮기자
클라이언트도 특정 컨텍스트에 묶이지 않기를 바란다면?

### 2. FACTORY 추가하기

```java
public class Factory {
    public Movie createAvatarMovie() {
        return new Movie("아바타",
                Duration.ofMinutes(120),
                Money.wons(10000),
                new AmountDiscountPolicy(...));
    }
}
```
client 는 오직 사용과 관련된 책임만 지고 생성과 관련된 어떤 지식도 가지지 않게 된다.

### 순수한 가공물에게 책임 할당하기
표현적 분해(representational decomposition) : 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것<br>

모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제점에 마주한다.<br>
이 떄 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체를 **PURE FABRICATION(순수한 가공물)** 이라고 부른다.<br>
행위적 분해(behavioral decomposition) : 도메인과 무관하게 기술적인 이유로 순수한 가공물을 추가(인공적인 객체 창조)

### 3. 의존성 주입
의존성 주입 : 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법<br>
외부에서 의존성의 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입<br>

- 생성자 주입
- setter 주입
- 메서드 주입

### 숨겨진 의존성은 나쁘다.
SERVICE LOCATOR 패턴 : 의존성을 해결할 객체들을 보관하는 일종의 저장소(AppConfig)<br>
가장 큰 단점은 퍼블릭 인터페이스 어디에도 의존성이 드러나지 않는다. 의존성을 숨긴다.<br>
이런 경우 에러발생은 컴파일 타임이 아닌 런타임에 가서야 발견하게 된다.<br>
이런 경우 클래스의 사용법을 알기 위해 내구 구현을 봐야되고 이는 캡슐화 위반으로 이어진다.

### 4. 의존성 역전 원칙
의존성 역전 원칙(Dependency Inversion Principle, DIP)
1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.

### SEPERATED INTERFACE 패턴
추상화된 클래스들끼리 같은 패키지에 존재하고, 구체화된 클래스는 추상화에 해당하는 새로운 패키지로 관리해야 한다.<br>
그래야 추상화 모듈을 하위 수준의 모듈과 완벽하게 독립시킬 수 있다.<br>

이러한 설계는 인터페이스의 소유권을 서버가 아닌 클라이언트에 위치시킨다.
